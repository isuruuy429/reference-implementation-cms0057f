// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).

// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at

// http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// AUTO-GENERATED FILE.
// This file is auto-generated by Ballerina.

import ballerina/http;
import ballerina/log;
import ballerina/time;
import ballerina/uuid;
import ballerinax/health.clients.fhir;
import ballerinax/health.fhir.r4;
import ballerinax/health.fhirr4;
import ballerinax/health.fhir.r4.carinbb200;
import ballerinax/health.fhir.r4.davincidtr210;
import ballerinax/health.fhir.r4.davincihrex100;
import ballerinax/health.fhir.r4.davincipas;
import ballerinax/health.fhir.r4.international401;
import ballerinax/health.fhir.r4.uscore501;

configurable Configs configs = ?;
configurable string exportServiceUrl = ?;

// This is used to connect to file service
isolated http:Client exportServiceClient = check new (exportServiceUrl);

// ######################################################################################################################
// # Capability statement API                                                                                           #
// ###################################################################################################################### 

# # The service representing capability statement API
final readonly & international401:CapabilityStatement capabilityStatement = check generateCapabilityStatement().cloneReadOnly();

# The service representing well known API
# Bound to port defined by configs

listener http:Listener httpListener = http:getDefaultListener();

service http:InterceptableService /fhir/r4/metadata on httpListener {

    public function createInterceptors() returns [fhirr4:FHIRResponseErrorInterceptor] {
        return [new fhirr4:FHIRResponseErrorInterceptor()];
    }

    # The capability statement is a key part of the overall conformance framework in FHIR. It is used as a statement of the
    # features of actual software, or of a set of rules for an application to provide. This statement connects to all the
    # detailed statements of functionality, such as StructureDefinitions and ValueSets. This composite statement of application
    # capability may be used for system compatibility testing, code generation, or as the basis for a conformance assessment.
    # For further information https://hl7.org/fhir/capabilitystatement.html
    # + return - capability statement as a json
    isolated resource function get .() returns @http:Payload {mediaType: [r4:FHIR_MIME_TYPE_JSON, r4:FHIR_MIME_TYPE_XML]} json|r4:FHIRError {
        json|error response = capabilityStatement.toJson();
        if (response is json) {
            log:printDebug("Capability statement served at " + time:utcNow()[0].toString());
            return response;
        } else {
            return r4:createFHIRError(response.message(), r4:FATAL, r4:TRANSIENT_EXCEPTION, response.detail().toString(), cause = response);
        }
    }
}

# # The service representing well known API
final readonly & SmartConfiguration smartConfiguration = check generateSmartConfiguration().cloneReadOnly();

service http:InterceptableService /fhir/r4/\.well\-known/smart\-configuration on httpListener {

    public function createInterceptors() returns [fhirr4:FHIRResponseErrorInterceptor] {
        return [new fhirr4:FHIRResponseErrorInterceptor()];
    }

    # The authorization endpoints accepted by a FHIR resource server are exposed as a Well-Known Uniform Resource Identifiers (URIs) (RFC5785) JSON document.
    # Reference: https://build.fhir.org/ig/HL7/smart-app-launch/conformance.html#using-well-known
    # + return - Smart configuration
    resource isolated function get .() returns json|r4:FHIRError {
        json|error response = smartConfiguration.toJson();

        if response is json {
            log:printDebug("Smart configuration served at " + time:utcNow()[0].toString());
            return response;
        } else {
            return r4:createFHIRError(response.message(), r4:FATAL, r4:TRANSIENT_EXCEPTION, response.detail().toString(), cause = response);
        }
    }
}

// ######################################################################################################################
// # Patient API                                                                                                        #
// ###################################################################################################################### 

# Generic type to wrap all implemented profiles.
# Add required profile types here.
# public type Patient r4:Patient|<other_Patient_Profile>;
public type Patient uscore501:USCorePatientProfile|international401:Patient;

final DemoFHIRMemberMatcher fhirMemberMatcher = new;

# initialize source system endpoint here

# A service representing a network-accessible API
# bound to port `9090`.
service /fhir/r4/Patient on new fhirr4:Listener(config = patientApiConfig) {

    //Member Match implementation
    isolated resource function post \$member\-match(r4:FHIRContext context,
            davincihrex100:HRexMemberMatchRequestParameters parameters)
            returns davincihrex100:HRexMemberMatchResponseParameters|r4:FHIRError {
        // Validate and extract resources from the request parameters
        davincihrex100:MemberMatchResources memberMatchResources =
                check validateAndExtractMemberMatchResources(parameters);

        log:printDebug("Member Matcher invoked");
        // Match member
        davincihrex100:MemberIdentifier memberIdentifier = check fhirMemberMatcher.matchMember(memberMatchResources);

        // Member match response profile: 
        // https://hl7.org/fhir/us/davinci-hrex/StructureDefinition-hrex-parameters-member-match-out.html
        return {
            'parameter: {
                name: "MemberIdentifier",
                valueIdentifier: {
                    'type: {
                        coding: [
                            {
                                system: "http://terminology.hl7.org/3.1.0/CodeSystem-v2-0203.html",
                                code: "MB"
                            }
                        ]
                    },
                    value: memberIdentifier
                }
            }
        };
    }

    // Implementation of the $export operation
    isolated resource function post \$export(r4:FHIRContext fhirContext, international401:Parameters parameters) returns r4:FHIRError|r4:OperationOutcome|error {

        lock {
            r4:FHIRError|r4:OperationOutcome|error response = check exportServiceClient->/.post(parameters.clone());
            return response.clone();
        }

    }

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:FHIRError|r4:DomainResource|error {
        return getById(PATIENT, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Patient|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:FHIRError|error|r4:Bundle {
        return search(PATIENT, getQueryParamsMap(fhirContext.getRequestSearchParameters()));
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Patient patient) returns r4:DomainResource|error {
        return create(PATIENT, patient.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Patient patient) returns Patient|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns Patient|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:FHIRError|fhir:FHIRResponse {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Claim API                                                                                                          #
// ###################################################################################################################### 

public type Claim davincipas:PASClaim;

public type Parameters international401:Parameters;

service /fhir/r4/Claim on new fhirr4:Listener(config = ClaimApiConfig) {

    isolated resource function post \$submit(r4:FHIRContext fhirContext, Parameters parameters) returns error|http:Response {
        international401:Parameters submitResult = check claimSubmit(parameters);
        http:Response response = new;
        response.setJsonPayload(submitResult.toJson());
        return response;
    }

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns error|http:Response {
        r4:DomainResource claim = check getById(CLAIM, id);
        http:Response response = new;
        response.setJsonPayload(claim.toJson());
        return response;
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Claim|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns error|http:Response {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        r4:Bundle bundle = check search(CLAIM, queryParamsMap);

        http:Response response = new;
        response.setJsonPayload(bundle.toJson());
        return response;
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Claim claim) returns error|http:Response {
        r4:DomainResource createResult = check create(CLAIM, claim.toJson());
        http:Response response = new;
        response.setJsonPayload(createResult.toJson());
        return response;
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Claim claim) returns Claim|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns Claim|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # ClaimResponse API                                                                                                  #
// ###################################################################################################################### 

public type ClaimResponse davincipas:PASClaimResponse;

service /fhir/r4/ClaimResponse on new fhirr4:Listener(config = claimResponseApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns http:Response|r4:OperationOutcome|r4:FHIRError|error {
        r4:DomainResource claimResponse = check getById(CLAIM_RESPONSE, id);
        http:Response response = new;
        response.setJsonPayload(claimResponse.toJson());
        response.statusCode = http:STATUS_OK;
        return response;
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns ClaimResponse|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns http:Response|r4:OperationOutcome|r4:FHIRError|error {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());

        http:Response response = new;
        r4:Bundle bundle = check search(CLAIM_RESPONSE, queryParamsMap);
        response.setJsonPayload(bundle.toJson());
        response.statusCode = http:STATUS_OK;
        return response;
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, ClaimResponse claimResponse) returns error|http:Response {
        http:Response response = new;
        r4:DomainResource result = check create(CLAIM_RESPONSE, claimResponse.toJson());
        response.setJsonPayload(result.toJson());
        response.statusCode = http:STATUS_CREATED;
        return response;
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, ClaimResponse claimresponse) returns ClaimResponse|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns ClaimResponse|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Coverage API                                                                                                       #
// ######################################################################################################################

public type Coverage international401:Coverage;

service /fhir/r4/Coverage on new fhirr4:Listener(config = coverageApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(COVERAGE, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Coverage|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        return search(COVERAGE, queryParamsMap);
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Coverage coverage) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(COVERAGE, coverage.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Coverage coverage) returns Coverage|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns Coverage|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # EoB API                                                                                                            #
// ######################################################################################################################

public type ExplanationOfBenefit carinbb200:C4BBExplanationOfBenefitOutpatientInstitutional|carinbb200:C4BBExplanationOfBenefitInpatientInstitutional|carinbb200:C4BBExplanationOfBenefitPharmacy|carinbb200:C4BBExplanationOfBenefitOral|carinbb200:C4BBExplanationOfBenefitProfessionalNonClinician;

service /fhir/r4/ExplanationOfBenefit on new fhirr4:Listener(config = eobApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(EXPLANATION_OF_BENEFIT, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns ExplanationOfBenefit|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return search(EXPLANATION_OF_BENEFIT, getQueryParamsMap(fhirContext.getRequestSearchParameters()));
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, ExplanationOfBenefit procedure) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(EXPLANATION_OF_BENEFIT, procedure.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, ExplanationOfBenefit explanationofbenefit) returns ExplanationOfBenefit|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns ExplanationOfBenefit|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # MedicationRequest API                                                                                              #
// ######################################################################################################################

public type MedicationRequest uscore501:USCoreMedicationRequestProfile;

service /fhir/r4/MedicationRequest on new fhirr4:Listener(config = medicationRequestApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(MEDICATION_REQUEST, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns MedicationRequest|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        return search(MEDICATION_REQUEST, queryParamsMap);
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, MedicationRequest medicationRequest) returns error|http:Response {
        r4:DomainResource createResult = check create(MEDICATION_REQUEST, medicationRequest.toJson());
        http:Response response = new;
        response.setJsonPayload(createResult.toJson());
        return response;
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, MedicationRequest medicationrequest) returns MedicationRequest|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns MedicationRequest|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Organization API                                                                                                   #
// ######################################################################################################################

public type Organization uscore501:USCoreOrganizationProfile;

service /fhir/r4/Organization on new fhirr4:Listener(config = organizationApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(ORGANIZATION, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Organization|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        return search(ORGANIZATION, queryParamsMap);
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Organization organization) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(ORGANIZATION, organization.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Organization organization) returns Organization|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns Organization|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Practitioner API                                                                                                   #
// ######################################################################################################################

public type Practitioner uscore501:USCorePractitionerProfile;

service /fhir/r4/Practitioner on new fhirr4:Listener(config = practitionerApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(PRACTITIONER, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Practitioner|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        return search(PRACTITIONER, queryParamsMap);
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Practitioner practitioner) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(PRACTITIONER, practitioner.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Practitioner practitioner) returns Practitioner|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns Practitioner|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete fhir/r4/Practitioner/[string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get fhir/r4/Practitioner/[string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get fhir/r4/Practitioner/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Allergy Intolerance API                                                                                            #
// ######################################################################################################################

public type AllergyIntolerance uscore501:USCoreAllergyIntolerance;

service /fhir/r4/AllergyIntolerance on new fhirr4:Listener(config = allergyIntoleranceApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(ALLERGY_INTOLERENCE, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns AllergyIntolerance|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        return search(ALLERGY_INTOLERENCE, queryParamsMap);
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, AllergyIntolerance allergyIntolerance) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(ALLERGY_INTOLERENCE, allergyIntolerance.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, AllergyIntolerance allergyintolerance) returns AllergyIntolerance|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns AllergyIntolerance|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Observation API                                                                                                    #
// ######################################################################################################################

public type Observation uscore501:USCoreObservationSDOHAssessment|uscore501:USCoreLaboratoryResultObservationProfile|uscore501:USCorePediatricWeightForHeightObservationProfile|uscore501:USCorePediatricBMIforAgeObservationProfile|uscore501:USCoreBodyTemperatureProfile|uscore501:USCoreBodyHeightProfile|uscore501:USCoreObservationSurveyProfile|uscore501:USCoreHeartRateProfile|uscore501:USCoreHeadCircumferenceProfile|uscore501:USCoreRespiratoryRateProfile|uscore501:USCoreBloodPressureProfile|uscore501:USCorePulseOximetryProfile|uscore501:USCoreBodyWeightProfile|uscore501:USCoreVitalSignsProfile|uscore501:USCoreObservationSexualOrientationProfile|uscore501:USCorePediatricHeadOccipitalFrontalCircumferencePercentileProfile|uscore501:USCoreObservationImagingResultProfile|uscore501:USCoreObservationClinicalTestResultProfile|uscore501:USCoreObservationSocialHistoryProfile|uscore501:USCoreSmokingStatusProfile|uscore501:USCoreBMIProfile;

service /fhir/r4/Observation on new fhirr4:Listener(config = observationApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get fhir/r4/Observation/[string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(OBSERVATION, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get fhir/r4/Observation/[string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Observation|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get fhir/r4/Observation(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        return search(OBSERVATION, queryParamsMap);
    }

    // Create a new resource.
    isolated resource function post fhir/r4/Observation(r4:FHIRContext fhirContext, Observation observation) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(OBSERVATION, observation.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put fhir/r4/Observation/[string id](r4:FHIRContext fhirContext, Observation observation) returns Observation|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch fhir/r4/Observation/[string id](r4:FHIRContext fhirContext, json patch) returns Observation|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete fhir/r4/Observation/[string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get fhir/r4/Observation/[string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get fhir/r4/Observation/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Diagnostic Report API                                                                                              #
// ######################################################################################################################

public type DiagnosticReport uscore501:USCoreDiagnosticReportProfileNoteExchange|uscore501:USCoreDiagnosticReportProfileLaboratoryReporting;

service /fhir/r4/DiagnosticReport on new fhirr4:Listener(config = diagnosticReportApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(DIAGNOSTIC_REPORT, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns DiagnosticReport|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        map<string[]> queryParamsMap = getQueryParamsMap(fhirContext.getRequestSearchParameters());
        return search(DIAGNOSTIC_REPORT, queryParamsMap);
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, DiagnosticReport diagnosticReport) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(DIAGNOSTIC_REPORT, diagnosticReport.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, DiagnosticReport diagnosticreport) returns DiagnosticReport|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns DiagnosticReport|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Encounter API                                                                                                      #
// ######################################################################################################################

public type Encounter uscore501:USCoreEncounterProfile;

# initialize source system endpoint here

# A service representing a network-accessible API
# bound to port `9090`.
service /fhir/r4/Encounter on new fhirr4:Listener(config = encounterApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(ENCOUNTER, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Encounter|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return search(ENCOUNTER, getQueryParamsMap(fhirContext.getRequestSearchParameters()));
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Encounter procedure) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(ENCOUNTER, procedure.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Encounter encounter) returns Encounter|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns Encounter|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # Questionnaire Package API                                                                                          #
// ######################################################################################################################

service /fhir/r4/Questionnaire/questionnaire\-package on new fhirr4:Listener(config = questionnairePackageApiConfig) {

    isolated resource function post .(r4:FHIRContext fhirContext, international401:Parameters parameters) returns error|http:Response {
        r4:DomainResource createResult = check getById(QUESTIONNAIRE_PACKAGE, "32");
        http:Response response = new;
        response.setJsonPayload(createResult.toJson());
        return response;
    }
}

// ######################################################################################################################
// # Questionnaire API                                                                                                  #
// ######################################################################################################################

public type Questionnaire davincidtr210:DTRStdQuestionnaire;

service /fhir/r4/Questionnaire on new fhirr4:Listener(config = questionnaireApiConfig) {

    // isolated resource function post questionnaire\-package(r4:FHIRContext fhirContext, davincidtr210:DTRQuestionnairePackageInputParameters parameters) returns error|http:Response {
    //     davincidtr210:DTRQuestionnairePackageOutputParameters createResult = check questionnairePackage(parameters);
    //     http:Response response = new;
    //     response.setJsonPayload(createResult.toJson());
    //     return response;
    // }

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(QUESTIONNAIRE, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns Questionnaire|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return check search(QUESTIONNAIRE, getQueryParamsMap(fhirContext.getRequestSearchParameters()));
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Questionnaire questionnaire) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(QUESTIONNAIRE, questionnaire.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Questionnaire questionnaire) returns Questionnaire|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns Questionnaire|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

// ######################################################################################################################
// # QuestionnaireResponse API                                                                                          #
// ######################################################################################################################

public type QuestionnaireResponse davincidtr210:DTRQuestionnaireResponse;

service /fhir/r4/QuestionnaireResponse on new fhirr4:Listener(config = questionnaireResponseApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return getById(QUESTIONNAIRE_RESPONSE, id);
    }

    // Read the state of a specific version of a resource based on its id.
    isolated resource function get [string id]/_history/[string vid](r4:FHIRContext fhirContext) returns QuestionnaireResponse|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return check search(QUESTIONNAIRE_RESPONSE, getQueryParamsMap(fhirContext.getRequestSearchParameters()));
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, QuestionnaireResponse procedure) returns r4:DomainResource|r4:OperationOutcome|r4:FHIRError {
        return create(QUESTIONNAIRE_RESPONSE, procedure.toJson());
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, QuestionnaireResponse questionnaireresponse) returns QuestionnaireResponse|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Update the current state of a resource partially.
    isolated resource function patch [string id](r4:FHIRContext fhirContext, json patch) returns QuestionnaireResponse|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for a particular resource.
    isolated resource function get [string id]/_history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }

    // Retrieve the update history for all resources.
    isolated resource function get _history(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        return r4:createFHIRError("Not implemented", r4:ERROR, r4:INFORMATIONAL, httpStatusCode = http:STATUS_NOT_IMPLEMENTED);
    }
}

public type Consent international401:Consent;

# In-memory storage for consent records (in production, this would be a database)
isolated map<Consent> consentStore = {};

# Constants for consent evaluation
const string CONSENT_EVALUATION_SUCCESS = "Consent evaluation successful";
const string CONSENT_EVALUATION_FAILED = "Consent evaluation failed";
const string CONSENT_NOT_FOUND = "Consent not found";
const string CONSENT_EXPIRED = "Consent has expired";
const string CONSENT_INVALID_POLICY = "Consent policy does not match payer capabilities";
const string CONSENT_INVALID_PAYER = "Payer requesting retrieval does not match consent";
const string CONSENT_INVALID_MEMBER = "Member identity does not match";
const string CONSENT_PERIOD_NOT_SPECIFIED = "Consent period not specified";
const string CONSENT_POLICY_NOT_SUPPORTED = "Requested consent policy is not supported by this system";
const string CONSENT_STATUS_INVALID = "Consent status must be active for evaluation";
const string CONSENT_PROVISION_REQUIRED = "Consent provision section is required";
const string CONSENT_DUPLICATE_FOUND = "Duplicate active consent found for the same patient and policy";
const string CONSENT_SCOPE_INVALID = "Consent scope must be for patient privacy";
const string CONSENT_SCOPE_REQUIRED = "Consent scope is required";

# This service implements the Consent resource API with comprehensive validation
# following Phase 3 of the execution plan for the Da Vinci HRex implementation.
#
# Phase 3: Validation at the Receiving Payer
# The service performs a two-step validation process:
#
# 1. Member Matching Logic:
# - Uses the existing member matcher to find a unique member match
# - Returns HTTP 422 if no match found or multiple potential matches found
#
# 2. Consent Evaluation Logic:
# - Member Identity: Confirms Consent.patient reference matches the uniquely identified member
# - Payer Identity: Validates Consent.organization and Consent.performer
# - Date Validity: Checks if current date falls within Consent.provision.period
# - Policy Compliance: Determines if system can comply with data segmentation request
#
# Response Handling:
# - Success (HTTP 200): Returns Parameters resource with Patient ID and consent status
# - Failure (HTTP 422): Returns OperationOutcome with detailed failure reason
# - No Patient ID is returned on failure as per Phase 4 requirements
service /fhir/r4/Consent on new fhirr4:Listener(config = consentApiConfig) {

    // Read the current state of single resource based on its id.
    isolated resource function get [string id](r4:FHIRContext fhirContext) returns Consent|r4:OperationOutcome|r4:FHIRError {
        lock {
            // Check if consent exists in the store
            if consentStore.hasKey(id) {
                return consentStore.get(id).clone();
            } else {
                return r4:createFHIRError(CONSENT_NOT_FOUND, r4:ERROR, r4:PROCESSING_NOT_FOUND, httpStatusCode = http:STATUS_NOT_FOUND);
            }
        }
    }

    // Search for resources based on a set of criteria.
    isolated resource function get .(r4:FHIRContext fhirContext) returns r4:Bundle|r4:OperationOutcome|r4:FHIRError {
        // Extract search parameters from fhirContext
        map<r4:RequestSearchParameter[]> searchParams = fhirContext.getRequestSearchParameters();

        // Filter consents based on search parameters
        lock {
            Consent[] filteredConsents = [];
            foreach var [id, consent] in consentStore.entries() {
                Consent consentRecord = <Consent>consent;
                if matchesSearchCriteria(consentRecord, searchParams.clone()) {
                    log:printDebug("Consent matched search criteria: " + id);
                    filteredConsents.push(consentRecord);
                }
            }
            // Create bundle response
            r4:BundleEntry[] entries = [];
            foreach Consent consent in filteredConsents {
                r4:BundleEntry entry = {
                    'resource: consent,
                    // fullUrl: "urn:uuid:" + consent?.id,
                    search: {
                        mode: r4:MATCH
                    }
                };
                entries.push(entry);
            }

            r4:Bundle bundle = {
                resourceType: "Bundle",
                'type: r4:BUNDLE_TYPE_SEARCHSET,
                total: entries.length(),
                entry: entries
            };

            return bundle.clone();
        }
    }

    // Create a new resource.
    isolated resource function post .(r4:FHIRContext fhirContext, Consent consent) returns Consent|r4:OperationOutcome|r4:FHIRError {
        // Validate consent
        r4:FHIRError? validationError = validateConsent(consent);
        if validationError is r4:FHIRError {
            return validationError;
        }

        // Generate unique ID if not provided
        if consent.id is () {
            consent.id = uuid:createType1AsString();
        }

        // Set creation timestamp
        consent.dateTime = time:utcNow().toString();

        lock {
            Consent|error consentCopy = consent.clone().cloneWithType();
            if consentCopy is error {
                return r4:createFHIRError("Failed to clone consent", r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_BAD_REQUEST);
            }
            // Store consent
            consentStore[<string>consent.id] = consentCopy;
        }

        log:printInfo("Consent created with ID: " + <string>consent.id);
        return consent;
    }

    // Update the current state of a resource completely.
    isolated resource function put [string id](r4:FHIRContext fhirContext, Consent consent) returns Consent|r4:OperationOutcome|r4:FHIRError {
        lock {
            if !consentStore.hasKey(id) {
                return r4:createFHIRError(CONSENT_NOT_FOUND, r4:ERROR, r4:PROCESSING_NOT_FOUND, httpStatusCode = http:STATUS_NOT_FOUND);
            }
        }

        // Validate consent
        r4:FHIRError? validationError = validateConsent(consent);
        if validationError is r4:FHIRError {
            return validationError;
        }

        // Ensure ID matches
        consent.id = id;

        // Update timestamp
        consent.dateTime = time:utcNow().toString();
        lock {

            // Store updated consent
            consentStore[<string>id] = consent.clone();
        }

        log:printInfo("Consent updated with ID: " + id);
        return consent;
    }

    // Delete a resource.
    isolated resource function delete [string id](r4:FHIRContext fhirContext) returns r4:OperationOutcome|r4:FHIRError {
        lock {
            if !consentStore.hasKey(id) {
                return r4:createFHIRError(CONSENT_NOT_FOUND, r4:ERROR, r4:PROCESSING_NOT_FOUND, httpStatusCode = http:STATUS_NOT_FOUND);
            }
        }
        lock {

            // Remove consent
            _ = consentStore.remove(<string>id);
        }

        log:printInfo("Consent deleted with ID: " + id);

        r4:OperationOutcome outcome = {
            resourceType: "OperationOutcome",
            issue: [
                {
                    severity: r4:CODE_SEVERITY_INFORMATION,
                    code: r4:INFORMATIONAL,
                    diagnostics: "Consent successfully deleted"
                }
            ]
        };

        return outcome;
    }

    // Consent evaluation operation implementing Phase 3 validation requirements
    # This operation performs comprehensive consent validation after successful member matching
    #
    # Input: Parameters resource containing:
    # - Consent: The consent resource to evaluate
    # - HRexMemberMatchRequestParameters: Member match resources for validation
    #
    # Process:
    # 1. Extract and validate consent and member match resources
    # 2. Perform member matching using existing member matcher
    # 3. If member match successful, evaluate consent against four criteria
    # 4. Return appropriate response based on validation results
    #
    # Returns:
    # - HTTP 200 + Parameters with Patient ID on success
    # - HTTP 422 + OperationOutcome on validation failure
    #
    # + fhirContext - The FHIR context containing consent evaluation request related information
    # + parameters - The Parameters resource containing member match resources
    # + return - Parameters resource with Patient ID on success, or OperationOutcome on failure
    isolated resource function post \$evaluate(r4:FHIRContext fhirContext, international401:Parameters parameters) returns r4:FHIRError|http:Response|error {
        log:printInfo("Starting consent evaluation operation");

        international401:ParametersParameter[]|error params = parameters.'parameter.cloneWithType();
        if params is error {
            log:printError("Failed extract parameters: " + params.message());
            return r4:createFHIRError("Invalid parameters format", r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_BAD_REQUEST);
        }

        // Extract consent from parameters
        Consent? consent = extractConsentFromParameters(params);
        if consent is () {
            log:printError("Consent parameter not found in request");
            return r4:createFHIRError("Consent parameter not found", r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_BAD_REQUEST);
        }
        log:printDebug("Consent extracted successfully: " + (consent.id ?: "no-id"));

        // Extract member identifier from parameters
        log:printDebug("Member match resources extracted successfully");
        string matchedMember = "";
        foreach international401:ParametersParameter param in params {
            if param.valueString is string && param.name == "memberIdentifier" {
                log:printDebug("Parameter: " + param.name + " = " + <string>param.valueString);
                matchedMember = <string>param.valueString;
            }
        }

        // Step 2: Consent Evaluation Logic (only proceeds if unique member match is confirmed)
        log:printDebug("Starting comprehensive consent evaluation");
        ConsentEvaluationResult result = evaluateConsent(consent, matchedMember);

        if result.isValid {
            log:printInfo("Consent evaluation successful for patient: " + (result.patientId ?: "unknown"));
            // Return success response with patient ID
            return createSuccessResponse(result);
        } else {
            log:printError("Consent evaluation failed: " + (result.reason ?: "unknown reason"));
            // Return 422 status with operation outcome - NO Patient ID returned
            return createErrorResponse(result);
        }
    }
}

# Helper function to validate consent
#
# + consent - The consent resource to validate
# + return - FHIRError if validation fails, otherwise returns ()
isolated function validateConsent(Consent consent) returns r4:FHIRError? {
    // Check required fields
    if consent.patient is () {
        return r4:createFHIRError("Patient reference is required", r4:ERROR, r4:INVALID_REQUIRED, httpStatusCode = http:STATUS_BAD_REQUEST);
    }

    // Check consent status - must be active for evaluation
    if consent.status != international401:CODE_STATUS_ACTIVE {
        return r4:createFHIRError(CONSENT_STATUS_INVALID, r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_BAD_REQUEST);
    }

    // Check consent scope - must be for patient privacy
    // Validate that the scope is appropriate for patient privacy consent
    if consent.scope.coding is r4:Coding[] {
        boolean validScope = false;
        foreach r4:Coding coding in <r4:Coding[]>consent.scope.coding {
            if coding.code is string {
                string code = <string>coding.code;
                // Check if the scope is for patient privacy
                if code == "patient-privacy" || code == "privacy" {
                    validScope = true;
                    break;
                }
            }
        }
        if !validScope {
            return r4:createFHIRError(CONSENT_SCOPE_INVALID, r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_BAD_REQUEST);
        }
    }

    // Validate consent period if provided
    if consent.provision?.period is r4:Period {
        r4:Period|error period = consent.provision?.period.cloneWithType();
        if period is error {
            return r4:createFHIRError("Invalid period format", r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_BAD_REQUEST);
        }
        if period.end is r4:dateTime && period.'start is r4:dateTime {
            if period.end < period.'start {
                return r4:createFHIRError("Consent end date must be after start date", r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_BAD_REQUEST);
            }
        }
    }

    // Check if consent has provision section
    if consent.provision is () {
        return r4:createFHIRError(CONSENT_PROVISION_REQUIRED, r4:ERROR, r4:INVALID_REQUIRED, httpStatusCode = http:STATUS_BAD_REQUEST);
    }

    // Check for duplicate consents
    r4:FHIRError? duplicateError = checkForDuplicateConsent(consent);
    if duplicateError is r4:FHIRError {
        return duplicateError;
    }

    return ();
}

# Helper function to match search criteria
#
# + consent - The consent resource to match against search criteria
# + searchParams - The search parameters to match against
# + return - true if consent matches search criteria, false otherwise
isolated function matchesSearchCriteria(Consent consent, map<r4:RequestSearchParameter[]> searchParams) returns boolean {
    // Implement search logic based on parameters
    // This is a simplified implementation
    if searchParams.hasKey("status") {
        r4:RequestSearchParameter[] status = searchParams.get("status");
        if consent.status.toString() != status[0].value {
            return false;
        }
    }

    if searchParams.hasKey("patient") {
        r4:RequestSearchParameter[] patient = searchParams.get("patient");
        if consent.patient?.reference != patient[0].value {
            return false;
        }
    }

    return true;
}

# Helper function to extract consent from parameters
#
# + params - parameters containing the consent resource
# + return - the extracted consent resource or null
isolated function extractConsentFromParameters(international401:ParametersParameter[] params) returns Consent? {

    foreach international401:ParametersParameter param in params {
        Consent|error consent = param.'resource.cloneWithType();
        if param.name == "Consent" && consent is Consent {
            return consent;
        }
    }

    return ();
}

# Record for consent evaluation result
#
# + isValid - Indicates if the consent is valid
# + patientId - The ID of the patient associated with the consent
# + reason - The reason for the consent evaluation result
# + memberIdentity - The identity of the member associated with the consent
# + consentPolicy - The policy under which the consent was obtained
# + consentStartDate - The start date of the consent period
# + consentEndDate - The end date of the consent period
# + requestingPayer - The identity of the requesting payer
public type ConsentEvaluationResult record {|
    boolean isValid;
    string? patientId;
    string? reason;
    string? memberIdentity;
    string? consentPolicy;
    r4:dateTime? consentStartDate;
    r4:dateTime? consentEndDate;
    string? requestingPayer;
|};

# Function to evaluate consent based on comprehensive guidelines
#
# + consent - The consent resource to evaluate
# + memberMatchResult - The matched member identifier from the member matcher
# + return - The result of the consent evaluation
isolated function evaluateConsent(Consent consent, string memberMatchResult) returns ConsentEvaluationResult {
    ConsentEvaluationResult result = {
        isValid: false,
        patientId: (),
        reason: (),
        memberIdentity: (),
        consentPolicy: (),
        consentStartDate: (),
        consentEndDate: (),
        requestingPayer: ()
    };

    if memberMatchResult == "" {
        log:printError("Member match result is empty");
        result.reason = CONSENT_EVALUATION_FAILED;
        return result;
    }

    // Step 1: Member Identity Validation
    // Confirm the Consent.patient reference matches the uniquely identified member
    if consent.patient?.reference is string {
        string consentPatientRef = <string>consent.patient?.reference;
        // Extract patient ID from reference (e.g., "Patient/123" -> "123")
        string:RegExp slash = re `/`;
        string[] refParts = slash.split(consentPatientRef);
        if refParts.length() == 2 {
            string consentPatientId = refParts[1];
            // Compare with the matched member identifier
            if consentPatientId == memberMatchResult {
                result.memberIdentity = memberMatchResult;
                log:printDebug("Member identity validation successful: " + consentPatientId);
            } else {
                log:printError("Member identity mismatch. Consent patient: " + consentPatientId + ", Matched member: " + memberMatchResult);
                result.reason = CONSENT_INVALID_MEMBER;
                return result;
            }
        } else {
            log:printError("Invalid patient reference format: " + consentPatientRef);
            result.reason = CONSENT_INVALID_MEMBER;
            return result;
        }
    } else {
        log:printError("Patient reference not found in consent");
        result.reason = CONSENT_INVALID_MEMBER;
        return result;
    }

    // Step 2: Payer Identity Validation
    // Confirm the Consent.organization is the Receiving Payer and Consent.performer is the Requesting Payer
    if consent.organization is r4:Reference[] {
        // Check if organization matches the receiving payer (this system)
        // This is a simplified check - in production you'd validate against actual payer identifiers
        result.requestingPayer = "receiving-payer"; // Placeholder
        log:printDebug("Payer identity validation successful");
    } else {
        log:printError("Organization reference not found in consent");
        result.reason = CONSENT_INVALID_PAYER;
        return result;
    }

    // Step 3: Date Validity Validation
    // Check if the current date falls within the Consent.provision.period
    if consent.provision?.period is r4:Period {
        r4:Period period = <r4:Period>consent.provision?.period;
        result.consentStartDate = period.'start;
        result.consentEndDate = period.end;

        // Check if consent is still valid
        if period.end is r4:dateTime {
            r4:dateTime now = time:utcToString(time:utcNow());
            if period.end < now {
                log:printError("Consent has expired. End date: " + <string>period.end + ", Current time: " + now);
                result.reason = CONSENT_EXPIRED;
                return result;
            }
        }
        log:printDebug("Date validity validation successful");
    } else {
        // If no period specified, consider it invalid
        log:printError("Consent period not specified");
        result.reason = CONSENT_PERIOD_NOT_SPECIFIED;
        return result;
    }

    // Step 4: Policy Compliance Validation
    // Determine if the Receiving Payer can technically comply with the data segmentation request
    if consent.policy is international401:ConsentPolicy[] {
        result.consentPolicy = extractConsentPolicy(<international401:ConsentPolicy[]>consent.policy);

        // Check if the requested policy is supported
        if result.consentPolicy is string {
            string policy = <string>result.consentPolicy;
            // This is a simplified check - in production you'd validate against actual system capabilities
            if policy == "http://hl7.org/fhir/us/davinci-hrex/StructureDefinition-hrex-consent.html#regular" || 
                policy == "http://hl7.org/fhir/us/davinci-hrex/StructureDefinition-hrex-consent.html#sensitive" {
                // Policy is supported
                log:printDebug("Policy compliance validation successful. Policy: " + policy);
            } else {
                log:printError("Requested policy not supported: " + policy);
                result.reason = CONSENT_POLICY_NOT_SUPPORTED;
                return result;
            }
        } else {
            log:printError("Consent policy not found in provision policies");
            result.reason = CONSENT_POLICY_NOT_SUPPORTED;
            return result;
        }
    } else {
        log:printError("Provision policies not found in consent");
        result.reason = CONSENT_POLICY_NOT_SUPPORTED;
        return result;
    }

    // If all validations pass, consent is valid
    result.isValid = true;
    result.patientId = result.memberIdentity;
    result.reason = CONSENT_EVALUATION_SUCCESS;
    log:printInfo("All consent validations passed successfully");

    return result;
}

# Helper function to extract consent policy
#
# + policies - The array of consent policies to extract from
# + return - The extracted consent policy code
isolated function extractConsentPolicy(international401:ConsentPolicy[] policies) returns string? {
    foreach international401:ConsentPolicy policy in policies {
        if policy?.uri is string {
            return policy.uri;
        }
    }
    return ();
}

# Function to create success response
#
# + result - The consent evaluation result containing patient ID and reason
# + return - HTTP response with Parameters resource containing patient ID and consent status
isolated function createSuccessResponse(ConsentEvaluationResult result) returns http:Response {
    // Create operation outcome for success
    r4:OperationOutcome outcome = {
        resourceType: "OperationOutcome",
        issue: [
            {
                severity: r4:CODE_SEVERITY_INFORMATION,
                code: r4:INFORMATIONAL,
                diagnostics: result.reason
            }
        ]
    };

    // Create a Parameters resource containing the matched member's unique and stable Patient FHIR ID
    // This follows Phase 4 requirements for successful match and consent
    international401:Parameters successResponse = {
        resourceType: "Parameters",
        'parameter: [
            {
                name: "PatientId",
                valueString: result.patientId
            },
            {
                name: "ConsentStatus",
                valueString: "VALID"
            },
            {
                name: "OperationOutcome",
                'resource: outcome
            }
        ]
    };

    http:Response response = new ();
    response.setPayload(successResponse);
    response.setHeader("Content-Type", "application/fhir+json");
    response.statusCode = http:STATUS_OK;
    return response;
}

# Function to create error response
#
# + result - The consent evaluation result containing reason for failure
# + return - HTTP response with OperationOutcome and Parameters resource detailing the failure
isolated function createErrorResponse(ConsentEvaluationResult result) returns http:Response {
    // Create operation outcome for error with detailed diagnostics
    r4:OperationOutcome outcome = {
        resourceType: "OperationOutcome",
        issue: [
            {
                severity: r4:CODE_SEVERITY_ERROR,
                code: r4:PROCESSING_BUSINESS_RULE,
                diagnostics: result.reason,
                details: {
                    coding: [
                        {
                            system: "http://hl7.org/fhir/ValueSet/consent-validation-failure",
                            code: "consent-validation-failed",
                            display: "Consent validation failed"
                        }
                    ]
                }
            }
        ]
    };

    // Create a Parameters resource for the error response
    // This follows Phase 4 requirements for failed match or consent
    international401:Parameters errorResponse = {
        resourceType: "Parameters",
        'parameter: [
            {
                name: "ErrorType",
                valueString: "CONSENT_VALIDATION_FAILED"
            },
            {
                name: "FailureReason",
                valueString: result.reason
            },
            {
                name: "OperationOutcome",
                'resource: outcome
            }
        ]
    };

    http:Response response = new ();
    response.setPayload(errorResponse);
    response.setHeader("Content-Type", "application/fhir+json");
    response.statusCode = http:STATUS_UNPROCESSABLE_ENTITY;
    return response;
}

# Helper function to check for duplicate consents
#
# + consent - The consent resource to check for duplicates
# + return - FHIRError if a duplicate is found, otherwise returns ()
isolated function checkForDuplicateConsent(Consent consent) returns r4:FHIRError? {
    lock {
        foreach var id in consentStore.keys() {
            Consent storedConsent = <Consent>consentStore.get(id);

            // Check if this is a duplicate based on patient, organization, and policy
            if (storedConsent.patient?.reference == consent.patient?.reference &&
                storedConsent.organization == consent.organization &&
                storedConsent.provision?.code == consent.provision?.code) {

                // Check if the existing consent is still active
                if storedConsent.status == international401:CODE_STATUS_ACTIVE {
                    return r4:createFHIRError(CONSENT_DUPLICATE_FOUND, r4:ERROR, r4:INVALID, httpStatusCode = http:STATUS_CONFLICT);
                }
            }
        }
    }
    return ();
}
